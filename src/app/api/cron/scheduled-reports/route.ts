import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { generatePDF, ReportData } from "@/lib/report-generator";
import { sendEmail } from "@/lib/email";
import { logger } from "@/lib/logger";
import { startOfDay, subDays, subWeeks, subMonths, format, addDays, addWeeks, addMonths } from "date-fns";

/**
 * Scheduled Reports Cron Job
 * 
 * This endpoint should be called daily by a cron service (e.g., Vercel Cron)
 * It processes scheduled reports and sends them to configured recipients
 */

function verifyCronSecret(request: NextRequest): boolean {
  const authHeader = request.headers.get("authorization");
  const cronSecret = process.env.CRON_SECRET;
  
  if (!cronSecret) {
    return process.env.NODE_ENV === "development";
  }
  
  return authHeader === `Bearer ${cronSecret}`;
}

export async function GET(request: NextRequest) {
  if (!verifyCronSecret(request)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const today = startOfDay(new Date());
  const results = {
    reportsGenerated: 0,
    reportsSent: 0,
    errors: [] as string[],
  };

  try {
    // Find all active scheduled reports due today
    const scheduledReports = await prisma.reportSchedule.findMany({
      where: {
        isActive: true,
        nextRunAt: {
          lte: today,
        },
      },
    });

    logger.info("Processing scheduled reports", { count: scheduledReports.length });

    for (const schedule of scheduledReports) {
      try {
        // Get tenant info
        const tenant = await prisma.tenant.findUnique({
          where: { id: schedule.tenantId },
        });

        if (!tenant) {
          results.errors.push(`Tenant not found for schedule ${schedule.id}`);
          continue;
        }

        // Determine report period based on frequency
        let periodStart: Date;
        const periodEnd = today;

        switch (schedule.frequency) {
          case "daily":
            periodStart = subDays(today, 1);
            break;
          case "weekly":
            periodStart = subWeeks(today, 1);
            break;
          case "monthly":
            periodStart = subMonths(today, 1);
            break;
          default:
            periodStart = subDays(today, 1);
        }

        // Generate report data based on report type
        const reportData = await generateReportData(
          schedule.tenantId,
          schedule.reportType,
          tenant.companyName,
          periodStart,
          periodEnd
        );

        if (!reportData) {
          results.errors.push(`No data for report ${schedule.id}`);
          continue;
        }

        results.reportsGenerated++;

        // Generate PDF
        const pdfBlob = generatePDF(reportData);

        // Parse recipients (stored as JSON string or comma-separated)
        let recipientEmails: string[] = [];
        try {
          recipientEmails = JSON.parse(schedule.recipients);
        } catch {
          recipientEmails = schedule.recipients.split(",").map((e) => e.trim());
        }

        // Send email with report
        if (recipientEmails.length > 0) {
          const periodStr = `${format(periodStart, "MMM d")} - ${format(periodEnd, "MMM d, yyyy")}`;
          
          await sendEmail({
            to: recipientEmails,
            subject: `${reportData.title} - ${periodStr}`,
            html: `
              <h2>${reportData.title}</h2>
              <p>Please find your scheduled ${schedule.frequency} report for ${periodStr}.</p>
              <p>This report was automatically generated by Mechatronics.</p>
              <p><em>Report Type: ${schedule.reportType}</em></p>
              <p><a href="${process.env.NEXTAUTH_URL}/portal/reports">View in Dashboard</a></p>
            `,
            text: `${reportData.title}\n\nYour scheduled ${schedule.frequency} report for ${periodStr} is ready.\n\nView in Dashboard: ${process.env.NEXTAUTH_URL}/portal/reports`,
          });

          results.reportsSent++;
        }

        // Calculate next run date
        let nextRunAt: Date;
        switch (schedule.frequency) {
          case "daily":
            nextRunAt = addDays(today, 1);
            break;
          case "weekly":
            nextRunAt = addWeeks(today, 1);
            break;
          case "monthly":
            nextRunAt = addMonths(today, 1);
            break;
          default:
            nextRunAt = addDays(today, 1);
        }

        // Update schedule
        await prisma.reportSchedule.update({
          where: { id: schedule.id },
          data: {
            lastRunAt: new Date(),
            nextRunAt,
          },
        });

        logger.info("Report generated and sent", {
          scheduleId: schedule.id.toString(),
          reportType: schedule.reportType,
          recipients: recipientEmails.length,
        });
      } catch (error) {
        const errorMsg = `Failed to process report ${schedule.id}: ${error}`;
        results.errors.push(errorMsg);
        logger.error("Report generation failed", { scheduleId: schedule.id.toString() }, error instanceof Error ? error : undefined);
      }
    }

    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      results,
    });
  } catch (error) {
    logger.error("Scheduled reports cron error", {}, error instanceof Error ? error : undefined);
    return NextResponse.json(
      { error: "Failed to process scheduled reports", details: String(error) },
      { status: 500 }
    );
  }
}

async function generateReportData(
  tenantId: bigint,
  reportType: string,
  companyName: string,
  periodStart: Date,
  periodEnd: Date
): Promise<ReportData | null> {
  switch (reportType) {
    case "device_summary":
      return generateDeviceSummaryReport(tenantId, companyName, periodStart, periodEnd);
    case "alert_summary":
      return generateAlertSummaryReport(tenantId, companyName, periodStart, periodEnd);
    default:
      return generateDeviceSummaryReport(tenantId, companyName, periodStart, periodEnd);
  }
}

async function generateDeviceSummaryReport(
  tenantId: bigint,
  companyName: string,
  periodStart: Date,
  periodEnd: Date
): Promise<ReportData> {
  const devices = await prisma.tenantDevice.findMany({
    where: { tenantId },
    include: {
      inventory: {
        include: { deviceType: true },
      },
    },
  });

  const deviceData = devices.map((d) => ({
    name: d.nickname || `Device ${d.id}`,
    type: d.inventory?.deviceType?.name || "Unknown",
    status: d.status,
    lastSeen: d.lastSeenAt ? format(d.lastSeenAt, "MMM d, yyyy HH:mm") : "Never",
  }));

  const activeCount = devices.filter((d) => d.status === "active").length;
  const suspendedCount = devices.filter((d) => d.status === "suspended").length;

  return {
    title: `Device Summary Report - ${companyName}`,
    subtitle: "Overview of all devices and their status",
    generatedAt: new Date(),
    period: { start: periodStart, end: periodEnd },
    sections: [
      {
        title: "Summary",
        type: "summary",
        data: {
          "Total Devices": devices.length,
          "Active Devices": activeCount,
          "Suspended Devices": suspendedCount,
        },
      },
      {
        title: "Device List",
        type: "table",
        data: deviceData,
        columns: [
          { key: "name", label: "Device Name" },
          { key: "type", label: "Type" },
          { key: "status", label: "Status" },
          { key: "lastSeen", label: "Last Seen" },
        ],
      },
    ],
  };
}

async function generateAlertSummaryReport(
  tenantId: bigint,
  companyName: string,
  periodStart: Date,
  periodEnd: Date
): Promise<ReportData> {
  const alerts = await prisma.alert.findMany({
    where: {
      tenantId,
      createdAt: {
        gte: periodStart,
        lte: periodEnd,
      },
    },
    orderBy: { createdAt: "desc" },
    take: 100,
  });

  const alertData = alerts.map((a) => ({
    title: a.title,
    severity: a.severity,
    status: a.status,
    createdAt: format(a.createdAt, "MMM d, yyyy HH:mm"),
  }));

  const criticalCount = alerts.filter((a) => a.severity === "critical").length;
  const warningCount = alerts.filter((a) => a.severity === "warning").length;
  const resolvedCount = alerts.filter((a) => a.status === "resolved").length;

  return {
    title: `Alert Summary Report - ${companyName}`,
    subtitle: "Overview of alerts during the reporting period",
    generatedAt: new Date(),
    period: { start: periodStart, end: periodEnd },
    sections: [
      {
        title: "Summary",
        type: "summary",
        data: {
          "Total Alerts": alerts.length,
          "Critical Alerts": criticalCount,
          "Warning Alerts": warningCount,
          "Resolved Alerts": resolvedCount,
          "Open Alerts": alerts.length - resolvedCount,
        },
      },
      {
        title: "Recent Alerts",
        type: "table",
        data: alertData.slice(0, 50),
        columns: [
          { key: "title", label: "Alert" },
          { key: "severity", label: "Severity" },
          { key: "status", label: "Status" },
          { key: "createdAt", label: "Created At" },
        ],
      },
    ],
  };
}
